import{a as He,n as ne,o as Pe}from"../chunks/scheduler.DDaOzR71.js";import{S as ze,i as Be,e as n,s as o,c as i,g as l,a as r,b as q,d as a,f as s}from"../chunks/index.BfbdwTR0.js";import{H as Me}from"../chunks/core.Bns4Tjg1.js";import{c as qe}from"../chunks/cpp.COu7517n.js";function Ge(ie){let h,f="Minecraft Clone",G,g,le='Honestly I&#39;m surprise I haven&#39;t created something of a Minecraft clone already. I originally just wanted to play around with more in depth graphics programming (in 3D specifically) and prior to this I had only ever used <a href="https://processing.org/">Processing</a> and <a href="https://p5js.org/">p5.js</a>&#39;s 3D rendering capabilities, as well as <a href="https://threejs.org/">Three.js</a> for a cool basic online multiplayer game. Obviously these come with the benefits of JavaScript, but sadly,they also come with the drawbacks of JavaScript (or Java in the case of Processing). Because of this and a desire to improve my handle on the C++ standard lib, STL and language in general, I decided between OpenGL or Vulkan, which led me to pick OpenGL almost arbitrarily. I&#39;ve heard a lot about the two previously, and from my limited research I found that Vulkan was more &quot;low-level&quot; than OpenGL and therefore could get more performance squeezed out of it, but still it was harder and this was my first time being in the weeds of graphics programming, so I thought I&#39;d make things easy for myself and switch later if I felt I needed to.',D,b,oe='At this point, the people of reddit praised <a href="https://learnopengl.com/">learnopengl.org</a> so I followed it&#39;s tutorials, and would recommend it, or it&#39;s physical bool version, to anyone interested in dipping their toes. Either way, I got through the basics of rendering and started to figure out how I would put together a little Minecraft simulation, which I ended up deciding to call <a href="https://github.com/EggbertFluffle/Mingleburb">Mingleburb</a> for no reason other than I thought it was funny.',S,w,re="First, what do I want to happen with this little experiment:",O,y,he="<li>I want to be able to render blocks of different textures with culled faces (more on that later)</li> <li>Those blocks should be generated using Perlin Noise and held in chunks</li> <li>There should be free cam controls using the wasd and arrow key/mouse controls</li> <li>Blocks should be removable and placable by the player relative to where they look</li> <li>The entire project should be organized, from the make files, to the encapsulation of classes</li>",A,c,ce="World Data (pt.1)",E,k,de="The first and easiest bit to tackle was the creation of rendered blocks, and to do this I started by just creating a simple block struct that held some data. In my thinking, I wanted to hold the least amount of data possible for each block, and tried to make it's footprint as small as possible. I'll talk about the faces member variable later, but the others are pretty self explanatory, though they were modified later to be more efficient (as of now I'm being punished for fixing something that already worked as the entire simulation is bugged because of my memory greed T-T).",W,v,pe=`<code class="lang-c++"><span class="hljs-comment">//    Block.hpp</span>

<span class="hljs-keyword">struct</span> Block {
<span class="hljs-built_in">std</span>::stirng texture; <span class="hljs-comment">// Texture name for block</span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> faces; <span class="hljs-comment">// Which faces of the block are visible</span>
<span class="hljs-keyword">bool</span> air; <span class="hljs-comment">// Is this an air block</span>

Block() : air(<span class="hljs-literal">true</span>) {}
Block(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* textureName) : texture(textureName), air(<span class="hljs-literal">false</span>) {}
</code>`,F,j,ue="With that out of the way, these were simple stored in a c-style 3-dimensional array. Also at this point in the program, the entirely of the code base was 1 main.cpp file, and so I create a much nicer structure consisting of an App class that holds the Player, GameManager, and GraphicsManager with some like player having their own smaller classes like the Player&#39;s InputManager. This made everything a lot more organized, but this also began to become a little annoying. In C++, they way I learned to develop object oriented programs was to write a .h or .hpp file to hold all the declarations of a class, then implement that classes functions/constructors/whatever else in a separate .c or .cpp file. This is fine, but I wish it was easier to make edits in a .cpp or .hpp file and not have to make essentially the same changes in another files just so they agree with each other. I understand the appeal of header files but I just find this specific aspect annoying. Besides the point, with a structured code base the first major task I wanted to tackle was player input. This became pretty easy as I was using GLFW for my window creation and writing an InputManager based on callbacks and events was something I&#39;ve done countless times in JavaScript DOM with functions like <code>window.createEventListener(&quot;keydown&quot; (e) =&gt; { handleInput(e) };</code>.",N,d,me="Player Controls",R,I,fe="This proved to have two main challenges. First, I was completely ignorant to callbacks in C and C++, and for some reason didn&#39;t just Google it like any normal person, instead just messing around with global variables and gross c-style type casts until something worked. After that was more or less solved, I was onto camera movement. There are 3 directions I needed to concern myself with. And the way camera rotation functions in OpenGL is you give the camera a position for itself, and a position to look at. To combat this I just kept track of the pitch and yaw with variables in the Player class, and added a unit vector to the camera position according to those angles to give the camera the correct position. After some struggling this turned out as so <code>lookDir = glm::normalize(glm::vec3(std::cos(yaw), std::tan(pitch), std::sin(yaw)));</code> (glm being a math library for constructs such as vectors, quaternions and matrices commonly used to interface with OpenGL and GLSL shaders). With that done, I just attached these rotations to change when the arrow keys are pressed via the Player&#39;s InputManager class and would also attach these variables to the change in mouse position to give mouse controls which are toggle-able via the Globals.hpp file. As far as camera translation goes, it really is just some similar trigonometry. We need to translate <em>local</em> movement to <em>global</em> movement. This means if I press w I want the player, from it&#39;s perspective to move forward, or increase it&#39;s z position. But because the player can manipulate its pitch rotation, meaning that increasing the player&#39;s local z almost never translates directly to changing its global z. Therefore we increase the players global z by the <code>std::cos(yaw) * z + std::cos(yaw + PI / 2) * x</code> in the world x direction, where the x and y in that equation represent the player&#39;s local translation. This extends to <code>std::sin(yaw) * z + std::sin(yaw + PI / 2) * x</code> in the world z direction, and y is just directly mapped from local to world translation.",$,p,ge="Face Culling",J,x,be="Next up was face culling, which tells the renderer to only draw faces that the player is <em>able</em> to see to the screen. This effectively means if a block is next to another block, don&#39;t draw either of the faves that touch, that also means that we only really render the surfaces that touch air blocks on the surface (the surface being at y = 5 on a 10 x 10 x 10 &quot;chunk&quot;). This came with A LOT of segmentation faults that I had not the foggiest idea on how to debug. I eventually found the program GDB which is used to help debug c and c++ programs (I think) and was able to at least get the callstack before the segfault occurred. Still these remained insanely difficult to debug and iron out and a lot of considerations had to come into play. First I had to deduce how to tell OpenGL to render a block with missing faces, which was actually the majority of the blocks in the world. I came up with using an <code>unsigned char</code> to store each face. One pattern I decided on early is that if I had to refer to each axis in the 3D world or the faces of a cube, it would always follow the order of <code>+x, -x, +y, -y, +z, -z</code> to keep consistency. This turned into flipping 6 of the 8 bits in an <code>unsigned char</code> according to which faces of that Block should be rendered. I really liked my solution to this and in the following code snippet, in the <code>char</code>, any of the first 6 bits containing a 1 indicate that its corresponding face <em>should not</em> be rendered. We set those bigs with the bitwise or operator (&#39;|&#39;), and choose which bit to assign by bitshifting the the binary 0x10000000 to the right corresponding to the face index. One thing to note, getBlock will return &#39;nullptr&#39; if the requested block is out of bounds, and a <code>Block*</code> with an <code>id</code> of 0 if the block represents air (also air is skipped in the rendering process) Now the actually face culling:",U,T,we=`<code class="lang-c++">void GameManager::cullFaces(int x, int y, int z) {
        Block* <span class="hljs-built_in">block</span> = getBlock(x, y, z);
        unsigned char faces = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">block</span> == nullptr || <span class="hljs-built_in">block</span>-&gt;id == <span class="hljs-number">0</span>) <span class="hljs-built_in">return</span>;
        Block* dirs[<span class="hljs-number">6</span>] = {
                getBlock(x + <span class="hljs-number">1</span>, y, z),
                getBlock(x - <span class="hljs-number">1</span>, y, z),
                getBlock(x, y + <span class="hljs-number">1</span>, z),
                getBlock(x, y - <span class="hljs-number">1</span>, z),
                getBlock(x, y, z + <span class="hljs-number">1</span>),
                getBlock(x, y, z - <span class="hljs-number">1</span>),
        };

        <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) {
                unsigned char f = <span class="hljs-number">0b10000000</span> &gt;&gt; (i);
                Block* b = dirs[i];
                <span class="hljs-keyword">if</span> (b == nullptr || (b != nullptr &amp;&amp; b-&gt;id != <span class="hljs-number">0</span>)) {
                        faces = faces | f;
                }
        }
        faces = ~faces;

        <span class="hljs-built_in">block</span>-&gt;faces = faces;
}
</code>`,V,_,ye="This took quite a white to get right and I'm very proud of the result.",K,u,ke="Block Highlighting",Y,C,ve='The <code>id</code> that I mentioned also keeps track of the texture to be applied to each block, which are loaded using <a href="https://nothings.org/stb">stb_image</a>, and textured onto each face of the block. Additionally there&#39;s functionality for highlighting the block that the player is looking at. Currently I have a &quot;naive&quot; approach, depending on how you look at it, of creating a vector that essentially points what direction the player is looking, and is scaled up depending on the players viewDistance. Once this <code>reach</code> vector is created, we lerp across the the reach vector, adding the players position. For each stage of the lerp, we round the currently checked point to the nearest integer and attempt to get a block at that point. If the result is not nullptr or an air block, that is the selected block, the lerp stops, and we tell the block to highlight itself in the next render. This code comes out to look like this, and I will talk about why this is a naive approach in my opinion.',Q,L,je=`<code class="lang-c++">void Player::castBlockRay(GameManager* gameManager) {
        Block* <span class="hljs-built_in">block</span>;
        // a <span class="hljs-built_in">is</span> the interpolation <span class="hljs-built_in">values</span>
        // <span class="hljs-number">100</span> equally spaced vectors to test between the player <span class="hljs-keyword">and</span> its <span class="hljs-built_in">max</span> reach
        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">float</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">1.</span><span class="hljs-number">0f</span>; a += <span class="hljs-number">0.</span><span class="hljs-number">01f</span>) {
                // the actual lerping
                glm::vec3 reach(
                        <span class="hljs-built_in">position</span>.x + (lookDir.x * viewDistance) * a,
                        <span class="hljs-built_in">position</span>.y + (lookDir.y * viewDistance) * a,
                        <span class="hljs-built_in">position</span>.z + (lookDir.z * viewDistance) * a
                );
                // <span class="hljs-built_in">round</span> <span class="hljs-keyword">and</span> test <span class="hljs-keyword">for</span> a <span class="hljs-built_in">block</span>
                <span class="hljs-built_in">block</span> = gameManager-&gt;getBlock(
                        int(reach.x + <span class="hljs-number">0.5</span>),
                        int(reach.y + <span class="hljs-number">0.5</span>),
                        int(reach.z + <span class="hljs-number">0.5</span>)
                );
                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">block</span> != nullptr &amp;&amp; <span class="hljs-built_in">block</span>-&gt;id != <span class="hljs-number">0</span>) {
                        selectedBlock = <span class="hljs-built_in">block</span>; 
                        selectedBlockCoords = glm::vec3(
                                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">floor</span>(reach.x + <span class="hljs-number">0.5</span>),
                                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">floor</span>(reach.y + <span class="hljs-number">0.5</span>),
                                <span class="hljs-built_in">std</span>::<span class="hljs-built_in">floor</span>(reach.z + <span class="hljs-number">0.5</span>)
                        );
                        <span class="hljs-built_in">return</span>;
                }
        }
        selectedBlock = nullptr;
}
</code>`,X,M,Ie='One limitation I&#39;ve found with this method is that it can be inaccurate and miss blocks. Say the player is looking at the corner of a block and the ray from the players view begins to march forward to its max reach. If the lerped vector increases by too big a step at the corner, or edge, of the block it may skip past and the effect would be as if the player is highlighting a block that is behind the actual block they are looking at. Although this can be solved easily by simply testing more vectors between the player&#39;s position and the max reach, it still leaves one issue unresolved. With this method we cannot deduce what side of the block the player is looking at (reliably). One method could be that we record the distance that the ray is able to travel before it reaches a block, then afterwards cast another ray with a slight rotational offset so it lands a bit to the right of the first. With this we might be able to find the angle which the two collision points lie on and possible deduce what face the player is looking at but this comes with a lot of edge cases and inefficiencies. The other option is a method that is almost identical to the method I used in my <a href="https://eggbert.neocities.org/blogs/wolfenstein_terminal_raycaster">Wolfenstien style Terminal renderer</a>, where rays are cast and step across each axis by integer values and testing which of the 2 axis rays travel the least, and which blocks they collide with. In short, this will be able to give a concrete distance for how far the player&#39;s view ray is able to travel, and which side of the block that ray collides with, based on which axis ray it finds the closest. Though like many things I get the feeling there are far easier to implement and just as effective methods that I haven&#39;t thought of. One idea I got from <a href="https://www.cs.columbia.edu/~jrk/">Dr. John R. Kender</a> was to keep my eyes on the actually painting step of the graphics pipeline. What he suggested was to find which face quads are drawn in the center of the screen and, using the depth buffer, which face is the closest. I think this is a fantastic idea, but as it stands I&#39;m unsure how to get information from the GPU&#39;s GLSL shader code back to the CPU&#39;s c++ side of things. So for now I&#39;m going to leave this issue unresolved and perhaps return at a later date. If you have any ideas on how to implement this, I would love to hear them, so please feel free to e-mail me at hdiambrosio@gmail.com.',Z,m,xe="Project Organization",ee,H,Te='Coming into this the most &quot;project organization&quot; I did was throwing everything in a src folder and calling it good. But I took a different approach for this little experiment and really wanted to get to know the common tools of c++ better: those being <a href="https://www.gnu.org/software/make/manual/make.html">make</a> and <a href="https://www.sourceware.org/gdb/">gdb</a>. I knew what make did and the basics of getting a project compiled but several things were missing that I needed. First, as this project grew bigger, and especially when I started to add more 3rd party libraries, having to compile those every single time I made even the smallest of changed grew annoyingly slow, <em>ESPECIALLY</em> on my school&#39;s Chromebook where I programmed most of this. That being said I knew it was possible to only compile files that had changed, and after a quick video about the basics of make, I found this:',te,P,_e=`<code class="lang-make">./obj/%.o: %.cpp
    $(CPPC) $(CPPGLAGS) $(WARNINGS) -c -o $@ $^
</code>`,ae,z,Ce='There was some more moving parts to the real makefile, but this is main attraction, where I essentially tell make that if it needs any sort of object file that isn&#39;t already compiled into an object file, go compile just that file and continue. What this also allows is the skipping of compiling files that have not changed since the last run of make. Finally, a friend of mine <a href="https://squi.bid">squibid</a> suggested I use the shell command <code>pkg-config --libs --cflags glfw3</code> so that I could get the proper names of the library files I had to link to. This removed the need for me to change the makefile weather I was programming on my desktop running Void Linux, or my Chromebook running Debian, which both have different names for the glfw library files. This improved the workflow tremendously and I would have burn out of this project far sooner if I hadn&#39;t taken the time to at least learn the basics.',se,B,Le="The other lifesaver for this project was gdb or the GNU Project Debugger. This tool allows me to add a <code>-g</code> flag to my <code>g++</code> call and add debug information to the executable. Then running gdb on the file allows me to run the file until I reach a segmentation fault. The magic happens when I run <code>backtrace</code> which then gives me the call stack before my code went wrong. THIS!!! THIS GODSEND GIFT SAVED ME HOURS!!! Before gdb, I used to just comment out code until I didn&#39;t get segfaults, then try to puzzle out the issue, only to get a completely unrelated segfault right afterwards. I still get them quite often and were huge demotivators in the development of Mingleburb but you live and you learn. Either way I want to become more familiar with gdb in the future as it seems to have a lot of really useful features like being able to see the values of local variables, step through instructions, view Assembly outputs and use breakpoints in code.";return{c(){h=n("h1"),h.textContent=f,G=o(),g=n("p"),g.innerHTML=le,D=o(),b=n("p"),b.innerHTML=oe,S=o(),w=n("p"),w.textContent=re,O=o(),y=n("ol"),y.innerHTML=he,A=o(),c=n("h2"),c.textContent=ce,E=o(),k=n("p"),k.textContent=de,W=o(),v=n("pre"),v.innerHTML=pe,F=o(),j=n("p"),j.innerHTML=ue,N=o(),d=n("h2"),d.textContent=me,R=o(),I=n("p"),I.innerHTML=fe,$=o(),p=n("h2"),p.textContent=ge,J=o(),x=n("p"),x.innerHTML=be,U=o(),T=n("pre"),T.innerHTML=we,V=o(),_=n("p"),_.textContent=ye,K=o(),u=n("h2"),u.textContent=ke,Y=o(),C=n("p"),C.innerHTML=ve,Q=o(),L=n("pre"),L.innerHTML=je,X=o(),M=n("p"),M.innerHTML=Ie,Z=o(),m=n("h2"),m.textContent=xe,ee=o(),H=n("p"),H.innerHTML=Te,te=o(),P=n("pre"),P.innerHTML=_e,ae=o(),z=n("p"),z.innerHTML=Ce,se=o(),B=n("p"),B.innerHTML=Le,this.h()},l(e){h=i(e,"H1",{id:!0,"data-svelte-h":!0}),l(h)!=="svelte-3yv86n"&&(h.textContent=f),G=r(e),g=i(e,"P",{"data-svelte-h":!0}),l(g)!=="svelte-1au1nq6"&&(g.innerHTML=le),D=r(e),b=i(e,"P",{"data-svelte-h":!0}),l(b)!=="svelte-w8ywy6"&&(b.innerHTML=oe),S=r(e),w=i(e,"P",{"data-svelte-h":!0}),l(w)!=="svelte-9rqcdu"&&(w.textContent=re),O=r(e),y=i(e,"OL",{"data-svelte-h":!0}),l(y)!=="svelte-1mzly7y"&&(y.innerHTML=he),A=r(e),c=i(e,"H2",{id:!0,"data-svelte-h":!0}),l(c)!=="svelte-i6xfj1"&&(c.textContent=ce),E=r(e),k=i(e,"P",{"data-svelte-h":!0}),l(k)!=="svelte-h94sl5"&&(k.textContent=de),W=r(e),v=i(e,"PRE",{"data-svelte-h":!0}),l(v)!=="svelte-1937mr0"&&(v.innerHTML=pe),F=r(e),j=i(e,"P",{"data-svelte-h":!0}),l(j)!=="svelte-dq2acf"&&(j.innerHTML=ue),N=r(e),d=i(e,"H2",{id:!0,"data-svelte-h":!0}),l(d)!=="svelte-8rnwnl"&&(d.textContent=me),R=r(e),I=i(e,"P",{"data-svelte-h":!0}),l(I)!=="svelte-mpzd73"&&(I.innerHTML=fe),$=r(e),p=i(e,"H2",{id:!0,"data-svelte-h":!0}),l(p)!=="svelte-piwtaf"&&(p.textContent=ge),J=r(e),x=i(e,"P",{"data-svelte-h":!0}),l(x)!=="svelte-1ycusv4"&&(x.innerHTML=be),U=r(e),T=i(e,"PRE",{"data-svelte-h":!0}),l(T)!=="svelte-3s5qgy"&&(T.innerHTML=we),V=r(e),_=i(e,"P",{"data-svelte-h":!0}),l(_)!=="svelte-ub5waz"&&(_.textContent=ye),K=r(e),u=i(e,"H2",{id:!0,"data-svelte-h":!0}),l(u)!=="svelte-1jiaz59"&&(u.textContent=ke),Y=r(e),C=i(e,"P",{"data-svelte-h":!0}),l(C)!=="svelte-49lwby"&&(C.innerHTML=ve),Q=r(e),L=i(e,"PRE",{"data-svelte-h":!0}),l(L)!=="svelte-6b5pzm"&&(L.innerHTML=je),X=r(e),M=i(e,"P",{"data-svelte-h":!0}),l(M)!=="svelte-1f2x589"&&(M.innerHTML=Ie),Z=r(e),m=i(e,"H2",{id:!0,"data-svelte-h":!0}),l(m)!=="svelte-11tep81"&&(m.textContent=xe),ee=r(e),H=i(e,"P",{"data-svelte-h":!0}),l(H)!=="svelte-1egiete"&&(H.innerHTML=Te),te=r(e),P=i(e,"PRE",{"data-svelte-h":!0}),l(P)!=="svelte-1vj6q5d"&&(P.innerHTML=_e),ae=r(e),z=i(e,"P",{"data-svelte-h":!0}),l(z)!=="svelte-1aoaedw"&&(z.innerHTML=Ce),se=r(e),B=i(e,"P",{"data-svelte-h":!0}),l(B)!=="svelte-vcp4b7"&&(B.innerHTML=Le),this.h()},h(){q(h,"id","minecraft-clone"),q(c,"id","world-data-pt-1-"),q(d,"id","player-controls"),q(p,"id","face-culling"),q(u,"id","block-highlighting"),q(m,"id","project-organization")},m(e,t){a(e,h,t),a(e,G,t),a(e,g,t),a(e,D,t),a(e,b,t),a(e,S,t),a(e,w,t),a(e,O,t),a(e,y,t),a(e,A,t),a(e,c,t),a(e,E,t),a(e,k,t),a(e,W,t),a(e,v,t),a(e,F,t),a(e,j,t),a(e,N,t),a(e,d,t),a(e,R,t),a(e,I,t),a(e,$,t),a(e,p,t),a(e,J,t),a(e,x,t),a(e,U,t),a(e,T,t),a(e,V,t),a(e,_,t),a(e,K,t),a(e,u,t),a(e,Y,t),a(e,C,t),a(e,Q,t),a(e,L,t),a(e,X,t),a(e,M,t),a(e,Z,t),a(e,m,t),a(e,ee,t),a(e,H,t),a(e,te,t),a(e,P,t),a(e,ae,t),a(e,z,t),a(e,se,t),a(e,B,t)},p:ne,i:ne,o:ne,d(e){e&&(s(h),s(G),s(g),s(D),s(b),s(S),s(w),s(O),s(y),s(A),s(c),s(E),s(k),s(W),s(v),s(F),s(j),s(N),s(d),s(R),s(I),s($),s(p),s(J),s(x),s(U),s(T),s(V),s(_),s(K),s(u),s(Y),s(C),s(Q),s(L),s(X),s(M),s(Z),s(m),s(ee),s(H),s(te),s(P),s(ae),s(z),s(se),s(B))}}}function De(ie){return Me.registerLanguage("cpp",qe),Pe(()=>{const h=document.getElementsByTagName("code");for(let f=0;f<h.length;f++)h[f].innerHTML=Me.highlight(h[f].innerText,{language:"cpp"}).value}),[]}class We extends ze{constructor(h){super(),Be(this,h,De,Ge,He,{})}}export{We as component};
