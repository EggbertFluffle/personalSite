<h1 id="advent-of-code-how-its-going">Advent of Code: How its Going</h1>
<p>As of writing this, day 19 is unlocking shortly (as in 1 minute) BUT, I&#39;m not going to do it. You might be wondering, &quot;All I hear this kid blabs about is Advent of Code.&quot;, &quot;Why isn&#39;t he doing it all of the sudden?&quot;. In short, I&#39;m washed. The long answer is that day 16 was no clicking for me, and still doesn&#39;t really, so it&#39;s making doing the other days more difficult. I also want to enjoy my winter vacation and see friends while I still can. One thing That I would like to mention is that I;m not using Zig. </p>
<h3 id="still-washed">Still washed</h3>
<p>I was able to do part 1 and 2 for day 1 in Zig, but then day 2 gave me some challenges, and with everything else going on at school, I didn&#39;t really have the time to justify doing Advent of Code twice a day. I still think Zig will be worth learning some day, but I also want to become even more familiar with C++ and I&#39;ve been in the &quot;really learn the tools&quot; mood, so I&#39;ve been browsing cppman and watching C+ YouTubers a lot. As of now, I have 2 stars on every day up until day 16 where I have 1 start for day 16 and 17. These days both seem pretty tough, I don&#39;t even know how to approach part 2 of day 16 and part 2 day 17 seems a little more doable but I really just don&#39;t have the motivation without having day 16 complete. Nonetheless, I still want to keep working towards getting those stars, and learning about C++ and good programming habits on the way. Two things I found out about myself is that I <em>DON&#39;T</em> work well at night, at all. I found myself frequently staying up for the Advent of Code drop, only to get stuck on part 2, go to bed disappointed and then solve it in as little as 30 minutes when I woke up the next day. I am not a night person and I destroyed my sleep schedule which I previously took a great amount of pride in. Second, talking to myself out loud makes it way easier to program efficiently. It may just be my inner wannabe YouTuber, but explaining things out loud to myself as I solve the problem makes it easier to stay focused and to make sense of the problem (also white-boarding is a huge help).</p>
<h2 id="the-c-language">The C++ Language</h2>
<p>Beyond those things about myself there is also A lot about the C++ programming language that I&#39;m learning too. Just listed as some unorganized tips:</p>
<h3 id="swapping-two-variables-integer-values-without-a-temporary-">Swapping two variables integer values without a temporary:</h3>
<p>If you want to swap two integer values without a temporary variable, you  can actually make use of bitwise XOR. Say I have two variables <code>int a = 3;</code> and <code>int b = 6;</code>. In order to swap I first get the XOR of b and a and store into a like so: <code>a = a ^ b;</code>. Then, XOR a and b into b, this should give the previous value of a into b. Finally, XOR the two values again but store into a. This should look something like this.</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&lbrace;

    <span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span> b = <span class="hljs-number">6</span>;

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a: %d, b: %d\n"</span>, a, b); <span class="hljs-comment">// a: 3, b: 6</span>

    a = a ^ b;
    b = a ^ b;
    a = a ^ b;

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a: %d, b: %d\n"</span>, a, b); <span class="hljs-comment">// a: 6, b: 3</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&rbrace;
</code></pre>
<h3 id="asserts-wow-how-did-i-not-use-these-sooner-">Asserts (wow how did i not use these sooner)</h3>
<p>An assert is <em>EXTREMELY</em> simple to understand. It is a macro from c and there are two types, static_asserts and good ol&#39; regular, run-of-the-mill, ordinary, plain, reliable, asserts. <code>assert()</code> is for ensuring the properties of values during runtime, and <code>static_assert()</code> is for checking the properties of values and types and stuff during compile-time (unfortunately, i have not delved too deep into compile-time stuff so i can&#39;t speak well to static assert). What makes assert useful is that, instead of printing values to the console and trying to piece together what is wrong with the values in the program, <code>assert()</code> will halt the entire program if the boolean expression passed returns false. What makes this even more <em>extra special</em> is that it GIVE YOU A LINE NUMBER! Gone are the days of being sad when gdb decides to play hard to get with it&#39;s line numbers for segfaults. Not only can assert guarantee some state of your program, but it&#39;s also far easier to track down the illegal state if it arises! I certainly see myself taking a closer look at <code>static_assert()</code> when I find the need to and throwing <code>assert()</code> calls all over my future code. This also seems to be a common thing in many languages so I&#39;m happy I understand what asserts are for now.</p>
<h3 id="templates-are-magic">Templates are Magic</h3>
<p>I still have <em>a lot</em> to learn about C++ templating. There seems to be a lot more to it that I don't currently understand. I only just learned that <code>template &lt;typename T&gt;</code> and <code>template &lt;class T&gt;</code> are subtly different and that you can extract a lot more from datatypes than I previously realized. Also it&#39;s so strange that the code regarding templates looks almost like standard C++, but it all happens at compile time! The reason I had to dig so far into templates is because as I was Advent of Code, I was putting together a useful utilities header file that proved extremely useful for patters in parsing inputs that happened often, or making a function that printed all the values in a vector, instead of me having to spend time typing a for loop with all the necessary line breaks and commas or however I wanted to format the output. I also wanted some functions like the higher-order array functions in JavaScript (map, for_each, every, some, filter and reduce). Some are present in the C++ algorithm header but I don&#39;t really care for the always defining the start and end of an iterator syntax that C++ uses. I sort of wish that most of these functions were overloaded to just take a container that has an iterator, and just run the specified method on the start to the end. For example:</p>
<pre><code class="lang-cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;array&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&lbrace;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 5&gt; arr(&lbrace;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&rbrace;);

    <span class="hljs-built_in">std</span>::for_each(arr.begin(), arr.end(), [](<span class="hljs-keyword">int</span> i)&lbrace; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">", "</span>; &rbrace;);

    <span class="hljs-comment">// Should perform the same functionality as...</span>
    <span class="hljs-built_in">std</span>::for_each(arr.begin(), [](<span class="hljs-keyword">int</span> i)&lbrace; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">", "</span>; &rbrace;);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&rbrace;
</code></pre>
<p>Regardless, templates start to become a little confusing (admittedly it could be a skill issue) when concerning functional types like lambdas. I still have a lot to learn regarding template and compile-time programming.</p>
<h2 id="the-rest-of-advent-of-code">The rest of Advent of Code</h2>
<p>For the rest of Advent of Code, I still wish to try it, but my attempts will be at a much more leisurely pace. Not that the puzzles are getting really tough, I need to think about them thoroughly, and can&#39;t just dive in and try to start programming some garbage solutions in order to finish the puzzle before no one. I do have a leader board, and it&#39;s <em>HUGE</em> this year which I am super psyched about, but I think I might have scared some of the participants off by doing so many puzzles so quick. It&#39;s not even as if they were that hard, just that it was finals week and I don&#39;t have my priorities straight. Either way I really hope that this is the year I can finally complete and Advent of Code calendar in it&#39;s fullest. Part of me wishes I was still at prep and I could bring my qualms to Dr. Kender and he would save the day with his infinite wisdom. That&#39;s about it regarding advent of code. If anyone wants to join my leader-board, the code is <code>2111709-786ea57b</code>. Hope everyone that is doing Advent of Code is enjoying it, and if anyone has questions about the puzzles or just wants to talk about them, feel free to e-mail me at <code>hdiambrosio@gmail.com</code>. Ok, bye bye! :)</p>
